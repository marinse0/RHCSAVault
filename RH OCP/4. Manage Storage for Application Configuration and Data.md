## Externalize the Configuration of Applications

### Objectives

- Configure applications by using Kubernetes secrets and configuration maps to initialize environment variables and to provide text and binary configuration files.
    

### Configuring Kubernetes Applications

When an application is run in Kubernetes with a pre-existing image, the application uses the default configuration. This action is valid for testing purposes. However, for production environments, you might need to customize your applications before deploying them.

With Kubernetes, you can use manifests in `JSON` and `YAML` formats to specify the intended configuration for each application. You can define the name of the application, labels, the image source, storage, environment variables, and more.

The following snippet shows an example of a `YAML` manifest file of a deployment:
```yaml
apiVersion: apps/v1 #1
kind: Deployment #2
metadata: #3
  name: hello-deployment
spec: #4
  replicas: 1
  selector:
    matchLabels:
      app: hello-deployment
  template:
    metadata:
      labels:
        app: hello-deployment
    spec: #5
      containers:
      - env: #6
        - name: ENV_VARIABLE_1
          valueFrom:
            secretKeyRef:
              key: hello
              name: world
        image: quay.io/hello-image:latest

```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO18-1)|API version of the resource.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO18-2)|`Deployment` resource type.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO18-3)|In this section, you specify the metadata of your application, such as the name.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO18-4)|You can define the general configuration of the resource that is applied to the deployment, such as the number of replicas (pods), the selector label, and the template data.|
|[![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO18-5)|In this section, you specify the configuration for your application, such as the image name, the container name, ports, environment variables, and more.|
|[![6](https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO18-6)|You can define the environment variables to configure your application needs.|

Sometimes your application requires configuring a combination of files. For example, at the time of creation, a database deployment must have preloaded databases and data. You most commonly configure applications by using environment variables, external files, or command-line arguments. This process of configuration externalization ensures that the application is portable across environments when the container image, external files, and environment variables are available in the environment where the application runs.

Kubernetes provides a mechanism to externalize the configuration of your applications by using configuration maps and secrets.

You can use configuration maps to inject containers with configuration data. The _ConfigMap_ (configuration map) namespaced objects provide ways to inject configuration data into containers, which helps to maintain platform independence of the containers. These objects can store fine-grained information, such as individual properties, or coarse-grained information, such as entire configuration files or JSON blobs (JSON sections). The information in configuration maps does not require protection.

The following listing shows an example of a configuration map:

```yaml
apiVersion: v1
kind: ConfigMap #1
metadata:
  name: example-configmap
  namespace: my-app
data: #2
  example.property.1: hello
  example.property.2: world
  example.property.file: |-
    property.1=value-1
    property.2=value-2
    property.3=value-3
binaryData: #3
  bar: L3Jvb3QvMTAw
```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO19-1)|`ConfigMap` resource type.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO19-2)|Contains the configuration data.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO19-3)|Points to an encoded file in base64 that contains non-UTF-8 data, for example, a binary Java keystore file. Place a key followed by the encoded file.|

Applications often require access to sensitive information. For example, a back-end web application requires access to database credentials to query a database. Kubernetes and OpenShift use secrets to hold sensitive information. For example, you can use secrets to store the following types of sensitive information:

- Passwords
    
- Sensitive configuration files
    
- Credentials to an external resource, such as an SSH key or OAuth token
    

The following listing shows an example of a secret:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: example-secret
  namespace: my-app
type: Opaque #1
data: #2
  username: bXl1c2VyCg==
  password: bXlQQDU1Cg==
stringData: #3
  hostname: myapp.mydomain.com
  secret.properties: |
    property1=valueA
    property2=valueB
```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO20-1)|Specifies the type of secret.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO20-2)|Specifies the encoded string and data.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_configuring_kubernetes_applications-CO20-3)|Specifies the decoded string and data.|

A secret is a namespaced object and it can store any type of data. Data in a secret is Base64-encoded, and is not stored in plain text. Secret data is not encrypted; you can decode the secret from Base64 format to access the original data. The following example shows the decoded values for the `username` and `password` objects from the `example-secret` secret:

[user@host] **`echo bXl1c2VyCg== | base64 --decode`**
myuser
[user@host] **`echo bXlQQDU1Cg== | base64 --decode`**
myP@55

Kubernetes and OpenShift support the following types of secrets:

- Opaque secrets: An opaque secret store key and value pairs that contain arbitrary values, and are not validated to conform to any convention for key names or values.
    
- Service account tokens: Store a token credential for applications that authenticate to the Kubernetes API.
    
- Basic authentication secrets: Store the needed credentials for basic authentication. The data parameter of the secret object must contain the user and the password keys that are encoded in the Base64 format.
    
- SSH keys: Store data that is used for SSH authentication.
    
- TLS certificates: Store a certificate and a key that are used for TLS.
    
- Docker configuration secrets: Store the credentials for accessing a container image registry.
    

When you store information in a specific secret resource type, Kubernetes validates that the data conforms to the type of secret.

**Note

By default, configuration maps and secrets are not encrypted. To encrypt your secret data at rest, you must encrypt the Etcd database. When enabled, Etcd encrypts the following resources: secrets, configuration maps, routes, OAuth access tokens, and OAuth authorization tokens. Encrypting the Etcd database is outside the scope of the course.

For more information, refer to the _Encrypting Etcd Data_ chapter in the Red Hat OpenShift Container Platform 4.14 _Security and Compliance_ documentation at [https://docs.redhat.com/en/documentation/openshift_container_platform/4.14/html-single/security_and_compliance/index#about-etcd_encrypting-etcd](https://docs.redhat.com/en/documentation/openshift_container_platform/4.14/html-single/security_and_compliance/index#about-etcd_encrypting-etcd)

### Creating Secrets

If a pod requires access to sensitive information, then create a secret for the information before you deploy the pod. Both the `oc` and `kubectl` command-line tools provide the `create secret` command. Use one of the following commands to create a secret:

- Create a generic secret that contains key-value pairs from literal values that are typed on the command line:
    
    [user@host ~]$ **`oc create secret generic secret_name \ --from-literal key1=secret1 \ --from-literal key2=secret2`**
    
- Create a generic secret by using key names that are specified on the command line and values from files:
    
    [user@host ~]$ **`kubectl create secret generic ssh-keys \ --from-file id_rsa=/path-to/id_rsa \ --from-file id_rsa.pub=/path-to/id_rsa.pub`**
    
- Create a TLS secret that specifies a certificate and the associated key:
    
    [user@host ~]$ **`oc create secret tls secret-tls \ --cert /path-to-certificate --key /path-to-key`**
    

To create an opaque secret from the web console, click the Workloads → Secrets menu. Click Create and select Key/value secret. Complete the form with the key name, and specify the value by writing it in the following section, or by extracting it from a file.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/configs/assets/kvscrt.png)|

To create a secret from the web console that stores the credentials for accessing a container image registry, click the Workloads → Secrets menu. Click Create and select Image pull secret. Complete the form or upload a configuration file with the secret name, select the authentication type, and add the registry server address, the username, password, and email credentials.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/configs/assets/impllscrt.png)|

### Creating Configuration Maps

The syntax for creating a configuration map and for creating a secret closely match. You can enter key-value pairs on the command line, or use the content of a file as the value of a specified key. You can use either the `oc` or `kubectl` command-line tools to create a configuration map. The following command shows how to create a configuration map:

[user@host ~]$ **`kubectl create configmap my-config \ --from-literal key1=config1 --from-literal key2=config2`**

You can also use the `cm` shortname to create a configuration map.

[user@host ~]$ **`oc create cm my-config \ --from-literal key1=config1 --from-literal key2=config2`**

To create a configuration map from the web console, click the Workloads → ConfigMaps menu. Click Create ConfigMap and complete the configuration map by using the form view or the YAML view.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/configs/assets/configmap-create.png)|

You can use files on each key that you add by clicking Browse beside the Value field. The Key field must be the name of the added file in the Value field.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/configs/assets/configmap-file.png)|

**Note

Use a binary data key instead of a data key if the file uses the binary format, such as a PNG file.

### Using Configuration Maps and Secrets to Initialize Environment Variables

You can use configuration maps to populate individual environment variables that configure your application. Unlike secrets, the information in configuration maps does not require protection. The following listing shows an initialization example of environment variables:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-map-example
  namespace: example-app #1
data:
  database.name: sakila #2
  database.user: redhat #3
```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO21-1)|The project where the configuration map resides. `ConfigMap` objects can be referenced only by pods in the same project.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO21-2)|Initializes the `database.name` variable to the `sakila` value.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO21-3)|Initializes the `database.user` variable to the `redhat` value.|

You can then use the configuration map to populate environment variables for your application. The following example shows a pod resource that populates specific environment variables by using a configuration map.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: config-map-example-pod
  namespace: example-app
spec:
  containers:
    - name: example-container
      image: registry.example.com/mysql-80:1-237
      command: [ "/bin/sh", "-c", "env" ]
      env: #1
        - name: MYSQL_DATABASE #2
          valueFrom:
            configMapKeyRef:
              name: config-map-example #3
              key: database.name #4
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: config-map-example #5
              key: database.user #6
              optional: true #7
```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO22-1)|The attribute to specify environment variables for the pod.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO22-2)|The name of a pod environment variable where you are populating a key's value.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO22-3) [![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO22-5)|Name of the `ConfigMap` object to pull the environment variables from.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO22-4) [![6](https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO22-6)|The environment variable to pull from the `ConfigMap` object.|
|[![7](https://rol.redhat.com/rol/static/roc/Common_Content/images/7.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO22-7)|Sets the environment variable as optional. The pod is started even if the specified `ConfigMap` object and keys do not exist.|

The following example shows a pod resource that injects all environment variables from a configuration map:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: config-map-example-pod2
  namespace: example-app
spec:
  containers:
    - name: example-container
      image: registry.example.com/mysql-80:1-237
      command: [ "/bin/sh", "-c", "env" ]
  envFrom: #1
    - configMapRef:
        name: config-map-example #2
  restartPolicy: Never

```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO23-1)|The attribute to pull all environment variables from a `ConfigMap` object.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO23-2)|The name of the `ConfigMap` object to pull environment variables from.|

You can use secrets with other Kubernetes resources such as pods, deployments, builds, and more. You can specify secret keys or volumes with a mount path to store your secrets. The following snippet shows an example of a pod that populates environment variables with data from the `test-secret` Kubernetes secret:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-example-pod
spec:
  containers:
    - name: secret-test-container
      image: busybox
      command: [ "/bin/sh", "-c", "export" ]
      env: #1
        - name: TEST_SECRET_USERNAME_ENV_VAR
          valueFrom: #2
            secretKeyRef: #3
              name: test-secret #4
              key: username #5

```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO24-1)|Specifies the environment variables for the pod.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO24-2)|Indicates the source of the environment variables.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO24-3)|The `secretKeyRef` source object of the environment variables.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO24-4)|Name of the secret, which must exist.|
|[![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)](https://rol.redhat.com/rol/app/#_using_configuration_maps_and_secrets_to_initialize_environment_variables-CO24-5)|The key that is extracted from the secret is the username for authentication.|

In contrast with configuration maps, the values in secrets are always encoded (not encrypted), and their access is restricted to fewer authorized users.

### Using Secrets and Configuration Maps as Volumes

To expose a secret to a pod, you must first create the secret in the same namespace, or project, as the pod. In the secret, assign each piece of sensitive data to a key. After creation, the secret contains key-value pairs.

The following command creates a generic secret that contains key-value pairs from literal values that are typed on the command line: `user` with the `demo-user` value, and `root_password` with the `zT1kTgk` value.

[user@host ~]$ **`oc create secret generic demo-secret \ --from-literal user=demo-user \ --from-literal root_password=zT1KTgk`**

You can also create a generic secret by specifying key names on the command line and values from files:

[user@host ~]$ **`oc create secret generic demo-secret \ --from-file user=/tmp/demo/user \ --from-file root_password=/tmp/demo/root_password`**

You can mount a secret to a directory within a pod. Kubernetes creates a file for each key in the secret that uses the name of the key. The content of each file is the decoded value of the secret. The following command shows how to mount secrets in a pod:

[user@host ~]$ **`oc set volume deployment/demo \ ![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg) --add --type secret \ ![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg) --secret-name demo-secret \ ![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg) --mount-path /app-secrets`** ![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_using_secrets_and_configuration_maps_as_volumes-CO25-1)|Modify the volume configuration in the `demo` deployment.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_using_secrets_and_configuration_maps_as_volumes-CO25-2)|Add a new volume from a secret.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_using_secrets_and_configuration_maps_as_volumes-CO25-3)|Use the `demo-secret` secret.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_using_secrets_and_configuration_maps_as_volumes-CO25-4)|Make the secret data available in the `/app-secrets` directory in the pod. The content of the `/app-secrets/user` file is `demo-user`. The content of the `/app-secrets/root_password` file is `zT1KTgk`.|

To assign a secret as a volume to a deployment from the web console, list the available secrets from the Workloads → Secrets menu.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/configs/assets/secrets-list.png)|

Select a secret and click Add Secret to workload.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/configs/assets/secret-slct.png)|

Select the workload, choose the Volume option, and define the mount path for the secret.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/configs/assets/secret-volume.png)|

Similar to secrets, you must first create a configuration map before a pod can consume it. The configuration map must exist in the same namespace, or project, as the pod. The following command shows how to create a configuration map from an external configuration file:

[user@host ~]$ **`oc create configmap demo-map \ --from-file=config-files/httpd.conf`**

You can similarly add a configuration map as a volume by using the following command:

[user@host ~]$ **`oc set volume deployment/demo \ --add --type configmap \ --configmap-name demo-map \ --mount-path /app-secrets`**

To confirm that the volume is attached to the deployment, use the following command:

[user@host ~]$ **`oc set volume deployment/demo`**
 demo
  configMap/demo-map as volume-du9in
    mounted at /app-secrets

You can also use the `oc set env` command to set application environment variables from either secrets or configuration maps. In some cases, you can modify the names of the keys to match the names of environment variables by using the `--prefix` option. In the following example, the `user` key from the `demo-secret` secret sets the `MYSQL_USER` environment variable, and the `root_password` key from the `demo-secret` secret sets the `MYSQL_ROOT_PASSWORD` environment variable. If the key name from the secret is lowercase, then the corresponding environment variable is converted to uppercase to match the pattern that the `--prefix` option defines.

[user@host ~]$ **`oc set env deployment/demo \ --from secret/demo-secret --prefix MYSQL_`**

**Note

You cannot assign configuration maps by using the web console.

### Updating Secrets and Configuration Maps

Secrets and configuration maps occasionally require updates. OpenShift provides the `oc extract` command to ensure that you have the latest data. You can save the data to a specific directory by using the `--to` option. Each key in the secret or configuration map creates a file with the same name as the key. The content of each file is the value of the associated key. If you run the `oc extract` command more than one time, then you must use the `--confirm` option to overwrite the existing files. You can also use the `--confirm` option to create the target directory for the extracted content.

[user@host ~]$ **`oc extract secret/demo-secrets -n demo \ --to /tmp/demo --confirm`**
[user@host ~]$ ls /tmp/demo/
user  root_password
[user@host ~]$ cat /tmp/demo/root_password
zT1KTgk
[user@host ~]$ echo k8qhcw3m0 > /tmp/demo/root_password

After updating the locally saved files, use the `oc set data` command to update the secret or configuration map. For each key that requires an update, specify the name of a key and the associated value. If a file contains the value, then use the `--from-file` option.

[user@host ~]$ **`oc set data secret/demo-secrets -n demo \ --from-file /tmp/demo/root_password`**

You must restart pods that use environment variables for the pods to read the updated secret or configuration map. Pods that use a volume mount to reference secrets or configuration maps receive the updates without a restart by using an eventually consistent approach. By default, the `kubelet` agent watches for changes to the keys and values that are used in volumes for pods on the node. The `kubelet` agent detects changes and propagates the changes to the pods to keep volume data consistent. Despite the automatic updates that Kubernetes provides, a restart of the pod is still required if the software reads configuration data only at startup time.

### Deleting Secrets and Configuration Maps

Similar to other Kubernetes resources, you can use the `delete` command to delete secrets and configuration maps that are no longer needed or in use.

[user@host ~]$ **`kubectl delete secret/demo-secrets -n demo`**

[user@host ~]$ **`oc delete configmap/demo-map -n demo`**

## Provision Persistent Data Volumes

### Objectives

- Provide applications with persistent storage volumes for block and file-based data.
    

### Kubernetes Persistent Storage

Containers have ephemeral storage by default. The lifetime of this ephemeral storage does not extend beyond the life of the individual pod, and this ephemeral storage cannot be shared across pods. When a container is deleted, all the files and data inside it are also deleted. To preserve the files, containers use persistent storage volumes.

Because OpenShift Container Platform uses the Kubernetes persistent volume (PV) framework, cluster administrators can provision persistent storage for a cluster. Developers can use persistent volume claims (PVCs) to request PV resources without specific knowledge of the underlying storage infrastructure.

Two ways exist to provision storage for the cluster: static and dynamic. Static provisioning requires the cluster administrator to create persistent volumes manually. Dynamic provisioning uses storage classes to create the persistent volumes on demand.

Administrators can use storage classes to provide persistent storage. Storage classes describe types of storage for the cluster. Cluster administrators create storage classes to manage storage services or storage tiers of a service. Rather than specifying provisioned storage, PVCs instead refer to a storage class.

Developers use PVCs to add persistent volumes to their applications. Developers need not know details of the storage infrastructure. With static provisioning, developers use previously created PVs, or ask a cluster administrator to manually create persistent volumes for their applications. With dynamic provisioning, developers declare the storage requirements of the application, and the cluster creates a PV to fill the request.

### Persistent Volumes

Not all storage is equal. Storage types vary in cost, performance, and reliability. Multiple storage types are usually available for each Kubernetes cluster.

The following list of commonly used storage volume types and their use cases is not exhaustive.

**configMap

The `configMap` volume externalizes the application configuration data. This use of the `configMap` resource ensures that the application configuration is portable across environments and can be version-controlled.

**emptyDir

An `emptyDir` volume provides a per-pod directory for scratch data. The directory is usually empty after provisioning. `emptyDir` volumes are often required for ephemeral storage.

**hostPath

A `hostPath` volume mounts a file or directory from the host node into your pod. To use a `hostPath` volume, the cluster administrator must configure pods to run as privileged. This configuration grants access to other pods in the same node.

Red Hat does not recommend the use of `hostPath` volumes in production. Instead, Red Hat supports `hostPath` mounting for development and testing on a single-node cluster. Although most pods do not need a `hostPath` volume, it does offer a quick option for testing if an application requires it.

**iSCSI

Internet Small Computer System Interface (iSCSI) is an IP-based standard that provides block-level access to storage devices. With iSCSI volumes, Kubernetes workloads can consume persistent storage from iSCSI targets.

**local

You can use `Local` persistent volumes to access local storage devices, such as a disk or partition, by using the standard PVC interface. `Local` volumes are subject to the availability of the underlying node, and are not suitable for all applications.

**NFS

An NFS (Network File System) volume can be accessed from multiple pods at the same time, and thus provides shared data between pods. The `NFS` volume type is commonly used because of its ability to share data safely. Red Hat recommends to use NFS only for non-production systems.

#### Volume Access Mode

Persistent volume providers vary in capabilities. A volume uses access modes to specify the modes that it supports. For example, NFS can support multiple read/write clients, but a specific NFS PV might be exported on the server as read-only. OpenShift defines the following access modes, as summarized in the following table:

**Table 5.1. Volume Access Modes**

|Access mode|Abbreviation|Description|
|:--|:--|:--|
|`ReadWriteOnce`|RWO|A single node mounts the volume as read/write.|
|`ReadOnlyMany`|ROX|Many nodes mount the volume as read-only.|
|`ReadWriteMany`|RWX|Many nodes mount the volume as read/write.|

  

Developers must select a volume type that supports the required access level by the application. The following table shows some example supported access modes:

**Table 5.2. Access Mode Support**

|Volume type|RWO|ROX|RWX|
|:--|:--|:--|:--|
|configMap|Yes|No|No|
|emptyDir|Yes|No|No|
|hostPath|Yes|No|No|
|iSCSI|Yes|Yes|No|
|local|Yes|No|No|
|NFS|Yes|Yes|Yes|

  

#### Volume Modes

Kubernetes supports two volume modes for persistent volumes: `Filesystem` and `Block`. If the volume mode is not defined for a volume, then Kubernetes assigns the default volume mode, `Filesystem`, to the volume.

OpenShift Container Platform can provision raw block volumes. These volumes do not have a file system, and can provide performance benefits for applications that either write to the disk directly or that implement their own storage service. Raw block volumes are provisioned by specifying `volumeMode: Block` in the PV and PVC specification.

The following table provides examples of storage options with block volume support:

**Table 5.3. Block Volume Support**

|Volume plug-in|Manually provisioned|Dynamically provisioned|
|:--|:--|:--|
|AWS EBS|Yes|Yes|
|Azure disk|Yes|Yes|
|Cinder|Yes|Yes|
|Fibre channel|Yes|No|
|GCP|Yes|Yes|
|iSCSI|Yes|No|
|local|Yes|No|
|Red Hat OpenShift Data Foundation|Yes|Yes|
|VMware vSphere|Yes|Yes|

  

#### Manually Creating a PV

Use a `PersistentVolume` manifest file to manually create a persistent volume. The following example creates a persistent volume from a fiber channel storage device that uses block mode.

```yaml
apiVersion: v1
kind: PersistentVolume #1
metadata:
  name: block-pv #2
spec:
  capacity:
    storage: 10Gi #3
  accessModes:
    - ReadWriteOnce #4
  volumeMode: Block #5
  persistentVolumeReclaimPolicy: Retain #6
  fc: #7
    targetWWNs: ["50060e801049cfd1"]
    lun: 0
    readOnly: false

```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_manually_creating_a_pv-CO26-1)|`PersistentVolume` is the resource type for PVs.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_manually_creating_a_pv-CO26-2)|Provide a name for the PV, which subsequent claims use to access the PV.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_manually_creating_a_pv-CO26-3)|Specify the amount of storage that is allocated to this volume.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_manually_creating_a_pv-CO26-4)|The storage device must support the access mode that the PV specifies.|
|[![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)](https://rol.redhat.com/rol/app/#_manually_creating_a_pv-CO26-5)|The `volumeMode` attribute is optional for `Filesystem` volumes, but is required for `Block` volumes.|
|[![6](https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg)](https://rol.redhat.com/rol/app/#_manually_creating_a_pv-CO26-6)|The `persistentVolumeReclaimPolicy` determines how the cluster handles the PV when the PVC is deleted. Valid options are `Retain` or `Delete`.|
|[![7](https://rol.redhat.com/rol/static/roc/Common_Content/images/7.svg)](https://rol.redhat.com/rol/app/#_manually_creating_a_pv-CO26-7)|The remaining attributes are specific to the storage type. In this example, the `fc` object specifies the `Fiber Channel` storage type attributes.|

If the previous manifest is in a file named `my-fc-volume.yaml`, then the following command can create the PV resource on RHOCP:

[user@host]$ **`oc create -f my-fc-volume.yaml`**

To create a persistent volume from the web console, click the Storage → PersistentVolumes menu.

### Persistent Volume Claims

A persistent volume claim (PVC) resource represents a request from an application for storage. A PVC specifies the minimal storage characteristics, such as capacity and access mode. A PVC does not specify a storage technology, such as iSCSI or NFS.

The lifecycle of a PVC is not tied to a pod, but to a namespace. Multiple pods from the same namespace but with potentially different workload controllers can connect to the same PVC. You can also sequentially connect storage to and detach storage from different application pods, to initialize, convert, migrate, or back up data.

Kubernetes matches each PVC to a persistent volume (PV) resource that can satisfy the requirements of the claim. It is not an exact match. A PVC might be bound to a PV with a larger disk size than is requested. A PVC that specifies single access might be bound to a PV that is shareable for multiple concurrent accesses. Rather than enforcing policy, PVCs declare what an application needs, which Kubernetes provides on a best-effort basis.

#### Creating a PVC

A PVC belongs to a specific project. To create a PVC, you must specify the access mode and size, among other options. A PVC cannot be shared between projects. Developers use a PVC to access a persistent volume (PV). Persistent volumes are not exclusive to projects, and are accessible across the entire OpenShift cluster. When a PV binds to a PVC, the PV cannot be bound to another PVC.

To add a volume to an application deployment, create a `PersistentVolumeClaim` resource, and add it to the application as a volume. Create the PVC by using either a Kubernetes manifest or the `oc set volumes` command. In addition to either creating a PVC or using an existing PVC, the `oc set volumes` command can modify a deployment to mount the PVC as a volume within the pod.

To add a volume to an application deployment, use the `oc set volumes` command:

[user@host ~]$ **`oc set volumes deployment/example-application \ ![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg) --add \ ![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg) --name example-pv-storage \ ![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg) --type persistentVolumeClaim \ ![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg) --claim-mode rwo \ ![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg) --claim-size 15Gi \ ![6](https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg) --mount-path /var/lib/example-app \ ![7](https://rol.redhat.com/rol/static/roc/Common_Content/images/7.svg) --claim-name example-pv-claim`** ![8](https://rol.redhat.com/rol/static/roc/Common_Content/images/8.svg)

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO27-1)|Specify the name of the deployment that requires the PVC resource.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO27-2)|Setting the `add` option to `true` adds volumes and volume mounts for containers.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO27-3)|The `name` option specifies a volume name. If not specified, a name is autogenerated.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO27-4)|The supported types, for the `add` operation, include `emptyDir`, `hostPath`, `secret`, `configMap`, and `persistentVolumeClaim`.|
|[![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO27-5)|The `claim-mode` option defaults to `ReadWriteOnce`. The valid values are `ReadWriteOnce (RWO)`, `ReadWriteMany (RWX)`, and `ReadOnlyMany (ROX)`.|
|[![6](https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO27-6)|Create a claim with the given size in bytes, if specified along with the persistent volume type. The size must use SI notation, for example, 15, 15 G, or 15 Gi.|
|[![7](https://rol.redhat.com/rol/static/roc/Common_Content/images/7.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO27-7)|The `mount-path` option specifies the mount path inside the container.|
|[![8](https://rol.redhat.com/rol/static/roc/Common_Content/images/8.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO27-8)|The `claim-name` option provides the name for the PVC, and is required for the `persistentVolumeClaim` type.|

The command creates a PVC resource and adds it to the application as a volume within the pod.

The command updates the deployment for the application with `volumeMounts` and `volumes` specifications.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  _...output omitted..._
  namespace: storage-volumes #1
  _...output omitted..._
spec:
  _...output omitted..._
  template:
  _...output omitted..._
    spec:
  _...output omitted..._
        **`volumeMounts:`**
        - mountPath: /var/lib/example-app #2
          name: example-pv-storage #3
  _...output omitted..._
      **`volumes:`**
      - name: example-pv-storage #4
        persistentVolumeClaim:
          claimName: example-pv-claim #5
  _...output omitted..._

```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO28-1)|The deployment, which must be in the same namespace as the PVC.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO28-2)|The mount path in the container.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO28-3) [![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO28-4)|The volume name, which is used to specify the volume that is associated with the mount.|
|[![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO28-5)|The claim name that is bound to the volume.|

The following example specifies a PVC by using a YAML manifest to create a `PersistentVolumeClaim` API object:

---
```yaml
apiVersion: v1
kind: PersistentVolumeClaim #1
metadata:
  name: example-pv-claim #2
  labels:
    app: example-application
spec:
  accessModes:
    - ReadWriteOnce #3
  resources:
    requests:
      storage: 15Gi #4

```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO29-1)|`PersistentVolumeClaim` is the resource type for a PVC.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO29-2)|Use this name in the `claimName` field of the `persistentVolumeClaim` element in the `volumes` section of a deployment manifest.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO29-3)|Specify the access mode that this PVC requests. The storage class provisioner must provide this access mode. If persistent volumes are created statically, then an eligible persistent volume must provide this access mode.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_creating_a_pvc-CO29-4)|The storage class creates a persistent volume that matches this size request. If persistent volumes are created statically, then an eligible persistent volume must be at least the requested size.|

Use the `oc create` command to create the PVC from the manifest file.

[user@host ~]$ **``oc create -f _`pvc_file_name.yaml`_``**

Use `oc get pvc` to view the available PVCs in the current namespace.

[user@host ~]$ **`oc get pvc`**
NAME         STATUS   VOLUME          CAPACITY   ACCESS MODES   STORAGECLASS   ...
db-pod-pvc   Bound    pvc-13...ca45   1Gi        RWO            nfs-storage    ...

To create a persistent volume claim from the web console, click the Storage → PersistentVolumesClaims menu.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/volumes/assets/storage-pvc.png)|

Click Create PersistentVolumeClaim and complete the form by adding the name, the storage class, the size, the access mode, and the volume mode.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/volumes/assets/pvc-form.png)|

#### Kubernetes Dynamic Provisioning

PVs are defined by a `PersistentVolume` API object, which is from existing storage in the cluster. The cluster administrator must statically provision some storage types. Alternatively, the Kubernetes persistent volume framework can use a `StorageClass` object to dynamically provision PVs.

When you create a PVC, you specify a storage amount, the required access mode, and a storage class to describe and classify the storage. The control loop in the RHOCP control node watches for new PVCs, and binds the new PVC to an appropriate PV. If an appropriate PV does not exist, then a provisioner for the storage class creates one.

Claims remain unbound indefinitely if a matching volume does not exist or if a volume cannot be created with any available provisioner that services a storage class. Claims are bound when matching volumes become available. For example, a cluster with many manually provisioned 50 Gi volumes would not match a PVC that requests 100 Gi. The PVC can be bound when a 100 Gi PV is added to the cluster.

Use `oc get storageclass` to view the storage classes that the cluster provides.

[user@host ~]$ **`oc get storageclass`**
NAME                    PROVISIONER                                  ...
nfs-storage (default)   k8s-sigs.io/nfs-subdir-external-provisioner  ...
lvms-vg1             topolvm.io                           ...

In the example, the `nfs-storage` storage class is marked as the default storage class. When a default storage class is configured, the PVC must explicitly name any other storage class to use, or can set the `storageClassName` annotation to "", to be bound to a PV without a storage class.

The following `oc set volume` command example uses the `claim-class` option to specify a dynamically provisioned PV.

[user@host ~]$ **`oc set volumes deployment/example-application \ --add --name example-pv-storage --type pvc --claim-class nfs-storage \ --claim-mode rwo --claim-size 15Gi --mount-path /var/lib/example-app \ --claim-name example-pv-claim`**

**Note

Because a cluster administrator can change the default storage class, Red Hat recommends that you always specify the storage class when you create a PVC.

#### PV and PVC Lifecycles

When you create a PVC, you request a specific amount of storage, access mode, and storage class. Kubernetes binds the PVC to an appropriate PV. If an appropriate PV does not exist, then a provisioner for the storage class creates one.

![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/storage/volumes/assets/pv-lifecycle.svg)

Figure 5.17: PV lifecycle

PVs follow a lifecycle based on their relationship to the PVC.

Available

After a PV is created, it becomes _available_ for any PVC to use in the cluster in any namespace.

Bound

A PV that is _bound_ to a PVC is also bound to the same namespace as the PVC, and no other PVC can use it.

In Use

You can delete a PVC if no pods actively use it. The _Storage Object in Use Protection_ feature prevents the removal of bound PVs and PVCs that pods are actively using. Such removal can result in data loss. Storage Object in Use Protection is enabled by default.

If a user deletes a PVC that a pod actively uses, then the PVC is not removed immediately. PVC removal is postponed until no pods actively use the PVC. Also, if a cluster administrator deletes a PV that is bound to a PVC, then the PV is not removed immediately. PV removal is postponed until the PV is no longer bound to a PVC.

Released

After the developer deletes the PVC that is bound to a PV, the PV is _released_, and the storage that the PV used can be reclaimed.

Reclaimed

The reclaim policy of a persistent volume tells the cluster what to do with the volume after it is released. A volume's reclaim policy can be Retain or Delete.

**Table 5.4. Volume Reclaim Policy**

|Policy|Description|
|:--|:--|
|Retain|Enables manual reclamation of the resource for those volume plug-ins that support it.|
|Delete|Deletes both the `PersistentVolume` object from OpenShift Container Platform and the associated storage asset in external infrastructure.|

  

#### Deleting a Persistent Volume Claim

To delete a volume, use the `oc delete` command to delete the PVC. The storage class reclaims the volume after removing the PVC.

[user@host ~]$ **`oc delete pvc/example-pvc-storage`**

## Select a Storage Class for an Application

### Objectives

- Match applications with storage classes that provide storage services to satisfy application requirements.
    

### Storage Class Selection

Storage classes are a way to describe types of storage for the cluster and to provision dynamic storage on demand. The cluster administrator determines the meaning of a storage class, which is also called a profile in other storage systems. For example, an administrator can create one storage class for development use, and another for production use.

Kubernetes supports multiple storage back ends. The storage options differ in cost, performance, reliability, and function. An administrator can create different storage classes for these options. As a result, developers can select the storage solution that fits the needs of the application. Developers do not need to know the storage infrastructure details.

Recall that an administrator selects the default storage class for dynamic provisioning. A default storage class enables Kubernetes to automatically provision a persistent volume claim (PVC) that does not specify a storage class. Because an administrator can change the default storage class, a developer should explicitly set the storage class for an application.

#### Reclaim Policy

Outside the application function, the developer must also consider the impact of the reclaim policy on storage requirements. A reclaim policy determines what happens to the data on a PVC after the PVC is deleted. When you are finished with a volume, you can delete the PVC object from the API, which enables reclamation of the resource. Kubernetes releases the volume when the PVC is deleted, but the volume is not yet available for another claim. The previous claimant's data remains on the volume and must be handled according to the policy. To keep your data, choose a storage class with a `retain` reclaim policy.

By using the `retain` reclaim policy, when you delete a PVC, only the PVC object is deleted from the cluster. The Persistent Volume (PV) that backed the PVC, the physical storage device that the PV used, and your data still exist. To reclaim the storage and use it in your cluster again, the cluster administrator must take manual steps.

To manually reclaim a PV as a cluster administrator, follow these steps:

1. Delete the PV.
    
    [user@host ~]$ **`oc delete pv <pv-name>`**
    
    The associated asset in the external storage infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume, still exists after the PV is deleted.
    
2. At this point, the cluster administrator can create another PV by using the same storage and data from the previous PV. A developer could then mount the new PV and access the data from the previous PV.
    
3. Alternatively, the cluster administrator can remove the data on the storage asset, and then delete the storage asset.
    

To automatically delete the PV, the data, and the physical storage for a deleted PVC, you must choose a storage class that uses the `delete` reclaim policy. This reclaim policy automatically reclaims your storage volume when the PVC is deleted. The `delete` reclaim policy is the default setting for all storage provisioners that adhere to the Kubernetes Container Storage Interface (CSI) standards. If you use a storage class that does not specify a reclaim policy, then the `delete` reclaim policy is used.

For more information about the Kubernetes Container Storage Interface standards, refer to the _Kubernetes CSI Developer Documentation_ website at [https://kubernetes-csi.github.io/docs/](https://kubernetes-csi.github.io/docs/).

#### Kubernetes and Application Responsibilities

Kubernetes does not change how an application relates to storage. The application is responsible for working with its storage devices and for ensuring data integrity and consistency. Kubernetes storage does not prevent an application from doing dangerous things, such as sharing a data volume between two databases that require exclusive access to data.

Because a PVC is a storage device that your Linux host mounts, an improperly configured application could behave unexpectedly. For example, you could have an iSCSI LUN, which is expressed as an RWO PVC that is not supposed to be shared, and then mount that same PVC on two pods of the same host. Whether this situation is problematic depends on the applications.

Usually, it is fine for two processes on the same host to share a disk. After all, many applications on your personal machine share a local disk. However, nothing prevents one text editor from overwriting and losing all edits from another text editor. The use of Kubernetes storage must come with the same caution.

Single-node access (RWO) and shared access (RWX) do not ensure that files can be shared safely and reliably. RWO means that only one cluster node can read and write to the PVC. Alternatively, with RWX, Kubernetes provides a storage volume that any pod can access for reading or writing.

### Use Cases for Storage Classes

The administrator creates storage classes that serve the needs of the developers. A `storageClass` object defines each storage class, and the object contains information about the storage provider and the capabilities of the storage medium. The provider creates PVs to match the specifications of the storage class. Administrators can create storage classes with various functional levels, based on many factors.

Storage volume modes

A storage class with `block` volume mode support can increase performance for applications that can use raw block devices. Consider using a storage class with `Filesystem` volume mode support for applications that share files or that provide file access.

Quality of Service (QoS) levels

A Solid State Drive (SSD) provides excellent speed and support for frequently accessed files. Use a lower cost and a slower hard drive (HDD) for files that are accessed less often.

Administrative support tier

A production-tier storage class can include volumes that are backed up often. In contrast, a development-tier storage class might include volumes that are not configured with a backup schedule.

Storage classes can use a combination of these factors and others to best fit the needs of the developers.

Kubernetes matches PVCs with the best available PV that is not bound to another PVC. The PV must provide the access mode that is specified in the PVC, and the volume must be at least as large as the requested size in the PVC. The supported access modes depend on the capabilities of the storage provider. A PVC can specify additional criteria, such as the name of a storage class. If a PVC cannot find a PV that matches all criteria, then the PVC enters a `pending` state and waits until an appropriate PV becomes available.

PVCs can request a specific storage class by specifying the `storageClassName` attribute. This method of selecting a specific storage class ensures that the storage medium is a good fit for the application requirements. Only PVs of the requested storage class can be bound to the PVC. The cluster administrator can configure dynamic provisioners to service storage classes. The cluster administrator can also create a PV on demand that matches the specifications in the PVC.

### Create a Storage Class

The following YAML excerpt describes the basic definition for a `StorageClass` object. A cluster administrator or a `storage-admin` user creates globally scoped `StorageClass` objects. The following resource shows the parameters for configuring a storage class. This example uses the AWS ElasticBlockStore (EBS) object definition.

```yaml
apiVersion: storage.k8s.io/v1 #1
kind: StorageClass #2
metadata:
  name: io1-gold-storage #3
  annotations: #4
    storageclass.kubernetes.io/is-default-class: 'false'
    description:'Provides RWO and RWOP Filesystem & Block volumes'
    ...
parameters: #5
  type: io1
  iopsPerGB: "10"
    ...
provisioner: kubernetes.io/aws-ebs #6
reclaimPolicy: Delete #7
volumeBindingMode: Immediate #8
allowVolumeExpansion: true #9

```

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-1)|A required item that specifies the current API version.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-2)|A required item that specifies the API object type.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-3)|A required item that specifies the name of the storage class.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-4)|An optional item that specifies annotations for the storage class.|
|[![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-5)|An optional item that specifies the required parameters for the specific provisioner; this object differs between plug-ins.|
|[![6](https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-6)|A required item that specifies the type of provisioner that is associated with this storage class.|
|[![7](https://rol.redhat.com/rol/static/roc/Common_Content/images/7.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-7)|An optional item that specifies the selected reclaim policy for the storage class.|
|[![8](https://rol.redhat.com/rol/static/roc/Common_Content/images/8.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-8)|An optional item that specifies the selected volume binding mode for the storage class.|
|[![9](https://rol.redhat.com/rol/static/roc/Common_Content/images/9.svg)](https://rol.redhat.com/rol/app/#_create_a_storage_class-CO30-9)|An optional item that specifies the volume expansion setting.|

Several attributes, such as the API version, API object type, and annotations, are common for Kubernetes objects, whereas other attributes are specific to storage class objects.

Parameters

Parameters can configure file types, change storage types, enable encryption, enable replication, and so on. Each provisioner has different parameter options. Accepted parameters depend on the storage provisioner. For example, the `io1` value for the `type` parameter, and the `iopsPerGB` parameter, are specific to EBS. When a parameter is omitted, the storage provisioner uses the default value.

Provisioners

The `provisioner` attribute identifies the source of the storage medium plug-in. Provisioners with names that begin with a `kubernetes.io` value are available by default in a Kubernetes cluster.

ReclaimPolicy

The default reclaim policy, `Delete`, automatically reclaims the storage volume when the PVC is deleted. Reclaiming storage in this way can reduce the storage costs. The `Retain` reclaim policy does not delete the storage volume, so that data is not lost if the wrong PVC is deleted. This reclaim policy can result in higher storage costs if space is not manually reclaimed.

VolumeBindingMode

The `volumeBindingMode` attribute determines how volume attachments are handled for a requesting PVC. Using the default `Immediate` volume binding mode creates a PV to match the PVC when the PVC is created. This setting does not wait for the pod to use the PVC, and thus can be inefficient. The `Immediate` binding mode can also cause problems for storage back ends that are topology-constrained or are not globally accessible from all nodes in the cluster. PVs are also bound without the knowledge of a pod's scheduling requirements, which might result in unschedulable pods.

By using the `WaitForFirstConsumer` mode, the volume is created after the pod that uses the PVC is in use. With this mode, Kubernetes creates PVs that conform to the pod's scheduling constraints, such as resource requirements and selectors.

AllowVolumeExpansion

When set to a `true` value, the storage class specifies that the underlying storage volume can be expanded if more storage is required. Users can resize the volume by editing the corresponding PVC object. This feature can be used only to grow a volume, not to shrink it.

The cluster administrator can use the `create` command to create a storage class from a YAML manifest file. The resulting storage class is non-namespaced, and thus is available to all projects in the cluster.

[user@host ~]$ **`oc create -f <storage-class-filename.yaml>`**

To create a storage class from the web console, click the Storage → StorageClasses menu. Click Create StorageClass and complete the form or the YAML manifest.

#### Cluster Storage Classes

Use the `oc get storageclass` command to view the storage class options that are available in a cluster.

[user@host ~]$ **`oc get storageclass`**

A regular cluster user can view the attributes of a storage class by using the `describe` command. The following example queries the attributes of the storage class with the name `lvms-vg1`.

[user@host ~]$ **`oc describe storageclass lvms-vg1`**
IsDefaultClass:        No
Annotations:           description=Provides RWO and RWOP Filesystem & Block volumes
Provisioner:           topolvm.io
Parameters:            csi.storage.k8s.io/fstype=xfs,topolvm.io/device-class=vg1
AllowVolumeExpansion:  True
MountOptions:          <none>
ReclaimPolicy:         Delete
VolumeBindingMode:     WaitForFirstConsumer
Events:                <none>

The `describe` command can help a developer to decide whether the storage class is a good fit for an application. If none of the storage classes in the cluster are appropriate for the application, then the developer can request the cluster administrator to create a PV with the required features.

### Storage Class Usage

Recall that the `oc set volume` command can add a PVC and an associated PV to a deployment. A YAML manifest file can declare the parameters of a PVC independently from the deployment. This method is the preferred option to support repeatability, configuration management, and version control. Use the `storageClassName` attribute to specify the storage class for the PVC.

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-block-pvc
spec:
  accessModes:
  - RWO
  volumeMode: Block
  **`storageClassName: <storage-class-name>`**
  resources:
    requests:
      storage: 10Gi


Use the `create` command to create the resource from the YAML manifest file.

[user@host ~]$ **`oc create -f <my-pvc-filename.yaml>`**

Use the `--claim-name` option with the `set volume` command to add the pre-existing PVC to a deployment.

[user@host ~]$ oc set volume deployment/<deployment-name> \
--add --name <my-volume-name> \
**`--claim-name my-block-pvc`** \
--mount-path /var/tmp


