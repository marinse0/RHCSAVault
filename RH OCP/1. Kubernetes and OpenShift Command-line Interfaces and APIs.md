# Operating a Production Cluster
## Red Hat OpenShift Key Concepts

When you navigate the OpenShift web console, it is useful to know some introductory OpenShift, Kubernetes, and container terminology. The following list includes some basic concepts that can help you to navigate the OpenShift web console.

- Pods: The smallest unit of a Kubernetes-managed containerized application. A pod consists of one or more containers.
- Deployments: The operational unit that provides granular management of a running application.
- Projects: A Kubernetes namespace with additional annotations that provide multitenancy scoping for applications.
- Routes: Networking configuration to expose your applications and services to resources outside the cluster.
- Operators: Packaged Kubernetes applications that extend cluster functions.

These concepts are covered in more detail throughout the course. You can find these concepts throughout the web console as you explore the features of an OpenShift cluster from the graphical environment.

## Accessing the OpenShift Web Console

You access the web console by any modern web browser. The web console URL is generally configurable, and you can discover the address for your cluster web console by using the `oc` command-line interface (CLI). 

From a terminal, you must first authenticate to the cluster via the CLI by using the `oc login -u <USERNAME> -p <PASSWORD> <API_ENDPOINT>:<PORT>` command:

```
[user@host ~]$ oc login -u developer -p developer https://api.ocp4.example.com:6443
Login successful.
```

Then, you execute the `oc whoami --show-console` command to retrieve the web console URL:

```
[user@host ~]$ oc whoami --show-console
https://console-openshift-console.apps.ocp4.example.com
```

Lastly, use a web browser to navigate to the URL, which displays the authentication page.

## Kubernetes Command-line Tool

The `oc` CLI installation also includes an installation of the `kubectl` CLI, which is the recommended method for installing the `kubectl` CLI for OpenShift users.

You can also install the `kubectl` CLI independently of the `oc` CLI. You must use a `kubectl` CLI version that is within one minor version difference of your cluster. For example, a `v1.26` client can communicate with `v1.25`, `v1.26`, and `v1.27` control planes. Using the latest compatible version of the `kubectl` CLI can help to avoid unforeseen issues.

To perform a manual installation of the `kubectl` binary for a Linux installation, you must first download the latest release by using the `curl` command.

```bash
user@host ~]$ curl -LO "https://dl.k8s.io/release/$(curl -L \   -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl
```

Then, you must download the `kubectl` checksum file and then validate the `kubectl` binary against the checksum file.

```bash
[user@host ~]$ curl -LO "https://dl.k8s.io/$(curl -L \ -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"

[user@host ~]$ echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
kubectl: OK
```

If the check fails, then the `sha256sum` command exits with nonzero status, and prints a `kubectl: FAILED` message.

You can then install the `kubectl` CLI.

```bash
[user@host ~]$ sudo install -o root -g root -m 0755 kubectl \
/usr/local/bin/kubectl
```

**Note**

If you do not have `root` access on the target system, you can still install the `kubectl` CLI to the `~/.local/bin` directory. For more information, refer to [https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/).

Finally, use the `kubectl version` command to verify the installed version. This command prints the client and server versions. Use the `--client` option to view the client version only.

```bash
[user@host ~]$ kubectl version --client
```

Alternatively, a distribution that is based on Red Hat Enterprise Linux (RHEL) can install the `kubectl` CLI with the following command:

```bash
[user@host ~]$ cat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
[user@host ~]$ sudo yum install -y kubectl
```

To view a list of the available `kubectl` commands, use the `kubectl --help` command.

```bash
[user@host ~]$ kubectl --help
kubectl controls the Kubernetes cluster manager.


 Find more information at:
https://kubernetes.io/docs/reference/kubectl/

Basic Commands (Beginner):
  create        Create a resource from a file or from stdin
  expose        Take a replication controller, service, deployment or pod and
expose it as a new Kubernetes Service
  run           Run a particular image on the cluster
  set           Set specific features on objects

Basic Commands (Intermediate):
_...output omitted..._
```

You can also use the `--help` option on any command to view detailed information about the command, including its purpose, examples, available subcommands, and options. For example, the following command provides information about the `kubectl create` command and its usage.

```bash
[user@host ~]$ kubectl create --help
Create a resource from a file or from stdin.

 JSON and YAML formats are accepted.

Examples:
  # Create a pod using the data in pod.json
  kubectl create -f ./pod.json

  # Create a pod based on the JSON passed into stdin
  cat pod.json | kubectl create -f -

  # Edit the data in registry.yaml in JSON then create the resource using the edited data
  kubectl create -f registry.yaml --edit -o json

Available Commands:
  clusterrole              Create a cluster role
  clusterrolebinfing   	   Create a cluster role binding for a particular cluster role
_...output omitted..._
```

Kubernetes uses many resource components to support applications. The `kubectl explain` command provides detailed information about the attributes of a given resource. For example, use the following command to learn more about the attributes of a `pod` resource.

```bash
[user@host ~]$ kubectl explain pod
KIND:     Pod
VERSION:  v1

DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.
FIELDS:
   apiVersion	<string>
     APIVersion defines the versioned schema of this representation of an
     object.
_...output omitted..._
```

Refer to [Kubernetes Documentation - Getting Started](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/) for further information about the `kubectl` commands.

## OpenShift Command-line Tool

The main method of interacting with an RHOCP cluster is by using the `oc` command.

You can download the `oc` CLI from the OpenShift web console to ensure that the CLI tools are compatible with the RHOCP cluster. From the OpenShift web console, navigate to Help → Command line tools. The Help menu is represented by a `?` icon. The web console provides several installation options for the `oc` client, such as downloads for the following operating systems:

- x86_64 Windows, Mac, and Linux systems
- ARM 64 Linux and Mac systems
- Linux for IBM Z, IBM Power, and little endian

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/cli/interfaces/assets/tools_screen.png)|

The basic usage of the `oc` command is through its subcommands in the following syntax:

```bash
[user@host ~]$ oc command
```

Because the `oc` CLI is a superset of the `kubectl` CLI, the `version`, `--help`, and `explain` commands are the same for both CLIs. However, the `oc` CLI includes additional commands that are not included in the `kubectl` CLI, such as the `oc login` and `oc new-project` commands.

## Managing Resources at the Command Line

Developers who are familiar with Kubernetes can use the `kubectl` utility to manage a RHOCP cluster. This course uses the `oc` command-line utility, to take advantage of additional RHOCP features. The `oc` commands manage resources that are exclusive to RHOCP, such as projects, deployment configurations, routes, and image streams.

Before you can interact with your RHOCP cluster, you must authenticate your requests. Use the `oc login` command to authenticate your requests. The `oc login` command provides role-based authentication and authorization that protects the RHOCP cluster from unauthorized access. The syntax to log in is shown below:

For example, in this course, you can use the following command:

```bash
[user@host ~]$ oc login https://api.ocp4.example.com:6443
Username: developer
Password: developer
Login successful.

You don't have any projects. You can try to create a new project, by running

  $ oc new-project <projectname>

Welcome to OpenShift! See 'oc help' to get started.

```

After authenticating to the RHOCP cluster, you can create a project with the `oc new-project` command. 

Projects provide isolation between your application resources. Projects are Kubernetes namespaces with additional annotations that provide multitenancy scoping for applications.

```bash
[user@host ~]$ oc new-project myapp
```

Several essential commands can manage RHOCP and Kubernetes resources, as described here. Unless otherwise specified, the following commands are compatible with both the `oc` and `kubectl` CLIs.

Some commands require a user with cluster administrator access. The following list includes several useful `oc` commands for cluster administrators.

### oc cluster-info

The `cluster-info` command prints the address of the control plane and other cluster services. The `oc cluster-info dump` command expands the output to include helpful details for debugging cluster problems.

```bash
[user@host ~]$ oc cluster-info
Kubernetes control plane is running at https://api.ocp4.example.com:6443
_...output omitted..._
```

### oc api-versions

The structure of cluster resources has a corresponding API version, which the `oc api-versions` command displays. The command prints the supported API versions on the server, in the form of "group/version".

In the following example, the group is `admissionregistration.k8s.io` and the version is `v1`:

```bash
[user@host ~]$ oc api-versions
admissionregistration.k8s.io/v1
_...output omitted..._
```

### oc get clusteroperator

The cluster operators that Red Hat ships serve as the architectural foundation for RHOCP. RHOCP installs cluster operators by default. Use the `oc get clusteroperator` command to see a list of the cluster operators:

```bash
[user@host ~]$ oc get clusteroperator
NAME                     VERSION    AVAILABLE PROGRESSING DEGRADED SINCE ...
authentication           4.14.0     True      False       False    18d
baremetal                4.14.0     True      False       False    18d
_...output omitted..._
```

Other useful commands are available to both regular and administrator users:

### oc get

Use the `get` command to retrieve information about resources in the selected project. Generally, this command shows only the most important characteristics of the resources, and omits more detailed information.

The ``oc get _`RESOURCE_TYPE`_`` command displays a summary of all resources of the specified type.

For example, the following command returns the list of the `pod` resources in the current project:

```bash
[user@host ~]$ oc get pod
NAME                          READY   STATUS    RESTARTS   AGE
quotes-api-6c9f758574-nk8kd   1/1     Running   0          39m
quotes-ui-d7d457674-rbkl7     1/1     Running   0          67s
```

You can use the `oc get RESOURCE_TYPE RESOURCE_NAME` command to export a resource definition. Typical use cases include creating a backup or modifying a definition. The `-o yaml` option prints the object representation in YAML format. You can change to JSON format by providing a `-o json` option.

### oc get all

Use the `oc get all` command to retrieve a summary of the most important components of a cluster. This command iterates through the major resource types for the current project, and prints a summary of their information:

```bash
[user@host ~]$ oc get all
NAME       DOCKER REPO                              TAGS      UPDATED
is/nginx   172.30.1.1:5000/basic-kubernetes/nginx   latest    About an hour ago

NAME       REVISION   DESIRED   CURRENT   TRIGGERED BY
dc/nginx   1          1         1         config,image(nginx:latest)

NAME         DESIRED   CURRENT   READY     AGE
rc/nginx-1   1         1         1         1h

NAME        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
svc/nginx   172.30.72.75   <none>        80/TCP,443/TCP   1h

NAME               READY     STATUS    RESTARTS   AGE
po/nginx-1-ypp8t   1/1       Running   0          1h
```

### oc describe

If the summaries from the `get` command are insufficient, then you can use the ``oc describe _`RESOURCE_TYPE`_ _`RESOURCE_NAME`_`` command to retrieve additional information. Unlike the `get` command, you can use the `describe` command to iterate through all the different resources by type. Although most major resources can be described, this function is not available across all resources. The following example demonstrates describing a pod resource:

```bash
[user@host ~]$ oc describe mysql-openshift-1-glgrp
Name:               mysql-openshift-1-glqrp
Namespace:          mysql-openshift
Priority:           0
Node:               cluster-worker-1/172.25.250.52
Start Time:         Fri, 15 Feb 2019 02:14:34 +0000
Labels:             app=mysql-openshift
                    deployment=mysql-openshift-1
_...output omitted..._
Status:             Running
IP:                 10.129.0.85
```

### oc explain

To learn about the fields of an API resource object, use the `oc explain` command. This command describes the purpose and the fields that are associated with each supported API resource. You can also use this command to print the documentation of a specific field of a resource. Fields are identified via a JSONPath identifier. The following example prints the documentation for the `.spec.containers.resources` field of the `pod` resource type:

```bash
[user@host ~]$ oc explain pods.spec.containers.resources
KIND:     Pod
VERSION:  v1

FIELD: resources <ResourceRequiremnts>

DESCRIPTION:
     Compute Resources required by this container. Cannot be updated. More info:
     https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

     ResourceRequirements describes the compute resource requirements.

FIELDS:
   claims       <[]ResourceClaim>
     Claims lists the names of resources, defined in spec.resourceClaims, that
     are used by this container.

     This is an alpha field nd requires enabling the DynamicResourceAllocation
     feature gate.

     This field is immutable. It can only be set for containers.

   limits	<map[string]Quantity>
     Limits describes the maximum amount of compute resources allowed. More
     info:
     https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

   requests	<map[string]Quantity>
     Requests describes the minimum amount of compute resources required. If
     Requests is omitted for a container, it defaults to Limits if that is
     explicitly specified, otherwise to an implementation-defined value. Requests
    cannot exceed Limits. More info:
     https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

```

Add the `--recursive` flag to display all fields of a resource without descriptions. Information about each field is retrieved from the server in OpenAPI format.

### oc create

Use the `create` command to create a RHOCP resource in the current project. This command creates resources from a resource definition. Typically, this command is paired with the `oc get RESOURCE_TYPE_ RESOURCE_NAME -o yaml` command for editing definitions. Developers commonly use the `-f` flag to indicate the file that contains the JSON or YAML representation of an RHOCP resource.

For example, to create resources from the `pod.yaml` file, use the following command:

```bash
[user@host ~]$ oc create -f pod.yaml
pod/quotes-pod created
```
RHOCP resources in the YAML format are discussed later.

### oc status

The `oc status` command provides a high-level overview of the current project. The command shows services, deployments, build configurations, and active deployments. Information about any misconfigured components is also shown. The `--suggest` option shows additional details for any identified issues.

### oc delete

Use the `delete` command to delete an existing RHOCP resource from the current project. You must specify the resource type and the resource name.

For example, to delete the `quotes-ui` pod, use the following command:

```bash
[user@host ~]$ oc delete pod quotes-ui
pod/quotes-ui deleted
```

A fundamental understanding of the RHOCP architecture is needed here, because deleting managed resources, such as pods, results in the automatic creation of new instances of those resources. When a project is deleted, it deletes all the resources and applications within it.

Each of these commands is executed in the current selected project. To execute commands in a different project, you must include the `--namespace` or `-n` options.

```bash
[user@host ~]$ oc get pods -n openshift-apiserver
NAME                         READY   STATUS    RESTARTS   AGE
apiserver-68c9485699-ndqlc   2/2     Running   2          18d
```

Refer to the references for a complete list of `oc` commands.

## Authentication with OAuth

For users to interact with RHOCP, they must first authenticate to the cluster. The authentication layer identifies the user that is associated with requests to the RHOCP API. After authentication, the authorization layer then uses information about the requesting user to determine whether the request is allowed.

A user in OpenShift is an entity that can make requests to the RHOCP API. An RHOCP `User` object represents an actor that can be granted permissions in the system by adding roles to the user or to the user's groups. Typically, this represents the account of a developer or an administrator.

Several types of users can exist.

Regular users

Most interactive RHOCP users are represented by this user type. An RHOCP `User` object represents a regular user.

System users

Infrastructure uses system users to interact with the API securely. Some system users are automatically created, including the cluster administrator, with access to everything. By default, unauthenticated requests use an anonymous system user.

Service accounts

`ServiceAccount` objects represent service accounts. RHOCP creates service accounts automatically when a project is created. Project administrators can create additional service accounts to define access to the contents of each project.

Each user must authenticate to access a cluster. After authentication, policy determines what the user is authorized to do.

**Note**

```
Authentication and authorization are covered in greater detail in the "DO280: Red Hat OpenShift Administration II: Operating a Production Kubernetes Cluster" course.
```

The RHOCP control plane includes a built-in OAuth server. To authenticate themselves to the API, users obtain OAuth access tokens. Token authentication is the only guaranteed method to work with any OpenShift cluster, because enterprise Single Sign-On (SSO) might replace the login form of the web console.

When a person requests a new OAuth token, the OAuth server uses the configured identity provider to determine the identity of the person who makes the request. The OAuth server then determines the user that the identity maps to; creates an access token for that user; and then returns the token for use.

To retrieve an OAuth token by using the OpenShift web console, navigate to Help → Command line tools. The Help menu is represented by a `?` icon.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/cli/interfaces/assets/select_command_line_tools.png)|

On the `Command Line Tools` page, navigate to Copy login Command. The following page requires you to log in with your OpenShift user credentials. Next, navigate to Display token. Use the command under the `Log in with this token` label to log in to the OpenShift API.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/cli/interfaces/assets/copy_login_command.png)|

Copy the command from the web console and paste it on the command line. The copied command uses the `--token` and `--server` options, similar to the following example.

```bash
[user@host ~]$ oc login --token=_`sha256-BW...rA8` \
--server=https://api.ocp4.example.com:6443
```

## Inspect Kubernetes Resources

### Kubernetes and OpenShift Resources

Kubernetes uses API resource objects to represent the intended state of everything in the cluster. All administrative tasks require creating, viewing, and changing the API resources. Use the `oc api-resources` command to view the Kubernetes resources.

```bash
[user@host ~]$ oc api-resources
NAME                    SHORTNAMES   APIVERSION   NAMESPACED   KIND
bindings                             v1           true         Binding
componentstatuses       cs           v1           false        ComponentStatus
configmaps              cm           v1           true         ConfigMap
endpoints               ep           v1           true         Endpoints
_...output omitted..._
daemonsets              ds           apps/v1      true         DaemonSet
deployments             deploy       apps/v1      true         Deployment
replicasets             rs           apps/v1      true         ReplicaSet
statefulsets            sts          apps/v1      true         StatefulSet
_...output omitted..._
```

The `SHORTNAME` for a component helps to minimize typing long CLI commands. For example, you can use `oc get cm` instead of `oc get configmaps`.

The `APIVERSION` column divides the objects into API groups. The column uses the `<API-Group>/<API-Version>` format. The `API-Group` object is blank for Kubernetes core resource objects.

Many Kubernetes resources exist within the context of a Kubernetes namespace. Kubernetes namespaces and OpenShift projects are broadly similar. A 1:1 relationship always exists between a namespace and an OpenShift project.

The `KIND` is the formal Kubernetes resource schema type.

The `oc api-resources` command can further filter the output with options that operate on the data.

**Table 2.1. The `api-resources` Command Options**

|Option Example|Description|
|:--|:--|
|`--namespaced=true`|If false, return non-namespaced resources, otherwise return namespaced resources|
|`--api-group apps`|Limit to resources in the specified API group. Use `--api-group=''` to show core resources.|
|`--sort-by name`|If non-empty, sort list of resources using specified field. The field can be either 'name' or 'kind'.|
  
For example, use the following `oc api-resources` command to see all the `namespaced` resources in the `apps` API group, sorted by `name`.

```bash
[user@host ~]$ oc api-resources --namespaced=true --api-group apps --sort-by name
NAME                  SHORTNAMES   APIVERSION   NAMESPACED   KIND
controllerrevisions                apps/v1      true         ControllerRevision
daemonsets            ds           apps/v1      true         DaemonSet
deployments           deploy       apps/v1      true         Deployment
replicasets           rs           apps/v1      true         ReplicaSet
statefulsets          sts          apps/v1      true         StatefulSet
```

Each resource contains fields that identify the resource or that describe the intended configuration of the resource. Use the `oc explain` command to get information about valid fields for an object. For example, execute the `oc explain pod` command to get information about possible pod object fields.

```bash
[user@host ~]$ oc explain pod
KIND:     Pod
VERSION:  v1

DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.

FIELDS:
   apiVersion	<string>
     APIVersion defines the versioned schema of this representation of an
     ...

   kind	<string>
     Kind is a string value representing the REST resource this object
     ...

   metadata	<ObjectMeta>
     Standard object's metadata. More info:
     ...

   spec	<PodSpec>
     Specification of the desired behavior of the pod. More info:
     _...output omitted..._
```

Every Kubernetes resource contains the `kind`, `apiVersion`, `spec`, and `status` fields. However, when you create an object definition, you do not need to provide the `status` field. Instead, Kubernetes generates the `status` field, and it lists information such as runtime status and readiness. The `status` field is useful for troubleshooting an error or for verifying the current state of a resource.

You can use the YAML path to a field and dot-notation to get information about a particular field. For example, the following `oc explain` command shows details for the `pod.spec` fields.

```bash
[user@host ~]$ oc explain pod.spec
KIND:     Pod
VERSION:  v1

FIELD: spec <PodSpec>

DESCRIPTION:
     Specification of the desired behavior of the pod. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

     PodSpec is a description of a pod.

FIELDS:
   activeDeadlineSeconds	<integer>
     Optional duration in seconds the pod may be active on the node relative to
    _...output omitted..._
```

The following Kubernetes main resource types can be created and configured by using a YAML or a JSON manifest file, or by using OpenShift management tools:

#### Pods (`pod`)

Represent a collection of containers that share resources, such as IP addresses and persistent storage volumes. It is the primary unit of work for Kubernetes.

#### Services (`svc`)

Define a single IP/port combination that provides access to a pool of pods. By default, services connect clients to pods in a round-robin fashion.

#### ReplicaSet (`rs`)

Ensure that a specified number of pod replicas are running at any given time.

#### Persistent Volumes (`pv`)

Define storage areas for Kubernetes pods to use.

#### Persistent Volume Claims (`pvc`)

Represent a request for storage by a pod. PVCs link a PV to a pod so that its containers can use the provisioned storage, usually by mounting the storage into the container's file system.

#### ConfigMaps (`cm`) and Secrets

Contain a set of keys and values that other resources can use. ConfigMaps and Secrets centralize configuration values that several resources use. Secrets differ from ConfigMaps in that the values of Secrets are always encoded (not encrypted), and their access is restricted to fewer authorized users.

#### Deployment (`deploy`)

A representation of a set of containers that are included in a pod, and the deployment strategies to use. A `deployment` object contains the configuration to apply to all containers of each pod replica, such as the base image, tags, storage definitions, and the commands to execute when the containers start. Although Kubernetes replicas can be created stand-alone in OpenShift, they are usually created by higher-level resources such as deployment controllers.

Red Hat OpenShift Container Platform (RHOCP) adds the following main resource types to Kubernetes:

#### BuildConfig (`bc`)

Defines a process to execute in the OpenShift project. The OpenShift Source-to-Image (S2I) feature uses a BuildConfig to build a container image from application source code that is stored in a Git repository. A `bc` works together with a `dc` to provide an extensible continuous integration and continuous delivery workflows.

Routes

Represent a DNS hostname that the OpenShift router recognizes as an ingress point for applications and microservices.

### Structure of Resources

Almost every Kubernetes object includes two nested object fields that govern the object's configuration: the object `spec` and the object `status`. The `spec` object describes the intended state of the resource, and the `status` object describes the current state. You specify the `spec` section of the resource when you create the object. Kubernetes controllers continuously update the `status` of the object throughout the existence of the object. The Kubernetes control plane continuously and actively manages every object's actual state to match the desired state you supplied.

The `status` field uses a collection of `condition` resource objects with the following fields.

**Table 2.2. Condition Resource Fields**

|Field|Example|Description|
|:--|:--|:--|
|Type|ContainersReady|The type of the condition|
|Status|False|The state of the condition|
|Reason|RequirementsNotMet|An optional field to provide extra information|
|Message|2/3 containers are running|An optional textual description for the condition|
|LastTransitionTime|2023-03-07T18:05:28Z|The last time that conditions were changed|

  

For example, in Kubernetes, a `Deployment` object can represent an application that is running on your cluster. When you create a `Deployment` object, you might configure the deployment `spec` object to specify that you want three replicas of the application to be running. Kubernetes reads the deployment `spec` object and starts three instances of your chosen application, and updates the `status` field to match your `spec` object. If any of those instances fails, then Kubernetes responds to the difference between the `spec` and `status` objects by making a correction, in this case to start a replacement instance.

Other common fields provide base information in addition to the `spec` and `status` fields of a Kubernetes object.

**Table 2.3. API Resource Fields**

|Field|Description|
|:--|:--|
|`apiVersion`|Identifier of the object schema version.|
|`kind`|Schema identifier.|
|`metadata.name`|Creates a label with a `name` key that other resources in Kubernetes can use to find it.|
|`metadata.namespace`|The namespace, or the RHOCP project where the resource is.|
|`metadata.labels`|Key-value pairs that can connect identifying metadata with Kubernetes objects.|

  

Resources in Kubernetes consist of multiple objects. These objects define the intended state of a resource. When you create or modify an object, you make a persistent record of the intended state. Kubernetes reads the object and modifies the current state accordingly.

All RHOCP and Kubernetes objects can be represented as a JSON or YAML structure. Consider the following pod object in the YAML format:

apiVersion: v1 ![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)
kind: Pod  ![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)
metadata: ![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)
  name: wildfly  ![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)
  namespace: my_app ![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)
  labels:
    name: wildfly  ![6](https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg)
spec: ![7](https://rol.redhat.com/rol/static/roc/Common_Content/images/7.svg)
  containers:
    - resources:
        limits:
          cpu: 0.5
      image: quay.io/example/todojee:v1  ![8](https://rol.redhat.com/rol/static/roc/Common_Content/images/8.svg)
      name: wildfly ![9](https://rol.redhat.com/rol/static/roc/Common_Content/images/9.svg)
      ports:
        - containerPort: 8080  ![10](https://rol.redhat.com/rol/static/roc/Common_Content/images/10.svg)
          name: wildfly
      env:  ![11](https://rol.redhat.com/rol/static/roc/Common_Content/images/11.svg)
        - name: MYSQL_DATABASE
          value: items
        - name: MYSQL_USER
          value: user1
        - name: MYSQL_PASSWORD
          value: mypa55
_...object omitted..._
status: ![12](https://rol.redhat.com/rol/static/roc/Common_Content/images/12.svg)
  conditions:
  - lastProbeTime: null
    lastTransitionTime: "2023-08-19T12:59:22Z"
    status: "True"
    type: PodScheduled

|   |   |
|---|---|
|[![1](https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-1)|Identifier of the object schema version.|
|[![2](https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-2)|Schema identifier. In this example, the object conforms to the pod schema.|
|[![3](https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-3)|Metadata for a given resource, such as annotations, labels, name, and namespace.|
|[![4](https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-4)|A unique name for a pod in Kubernetes that enables administrators to run commands on it.|
|[![5](https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-5)|The namespace, or the RHOCP project that the resource resides in.|
|[![6](https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-6)|Creates a label with a `name` key that other resources in Kubernetes, usually a service, can use to find it.|
|[![7](https://rol.redhat.com/rol/static/roc/Common_Content/images/7.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-7)|Defines the pod object configuration, or the intended state of the resource.|
|[![8](https://rol.redhat.com/rol/static/roc/Common_Content/images/8.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-8)|Defines the container image name.|
|[![9](https://rol.redhat.com/rol/static/roc/Common_Content/images/9.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-9)|Name of the container inside a pod. Container names are important for `oc` commands when a pod contains multiple containers.|
|[![10](https://rol.redhat.com/rol/static/roc/Common_Content/images/10.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-10)|A container-dependent attribute to identify the port that the container uses.|
|[![11](https://rol.redhat.com/rol/static/roc/Common_Content/images/11.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-11)|Defines a collection of environment variables.|
|[![12](https://rol.redhat.com/rol/static/roc/Common_Content/images/12.svg)](https://rol.redhat.com/rol/app/#_structure_of_resources-CO1-12)|Current state of the object. Kubernetes provides this field, which lists information such as runtime status, readiness, and container images.|

Labels are key-value pairs that you define in the `.metadata.labels` object path, for example:

kind: Pod
apiVersion: v1
metadata:
  name: example-pod
  labels:
    app: example-pod
    group: developers
_...object omitted..._

The preceding example contains the `app=example-pod` and `group=developers` labels. Developers often use labels to target a set of objects by using the `-l` or the `--selector` option. For example, the following `oc get` command lists pods that contain the `group=developers` label:

[user@host ~]$ **`oc get pod --selector group=developers`**
NAME                          READY   STATUS    RESTARTS   AGE
example-pod-6c9f758574-7fhg   1/1     Running   5          11d

### Command Outputs

The `kubectl` and `oc` CLI commands provide many output formatting options. By default, many commands display a small subset of the most useful fields for the given resource type in a tabular output. Many commands support a `-o wide` option that shows additional fields.

**Table 2.4. Tabular Fields**

|`oc get pods`|`oc get pods -o wide`|Example value|
|:--|:--|:--|
|NAME|NAME|example-pod|
|READY|READY|1/1|
|STATUS|STATUS|Running|
|RESTARTS|RESTARTS|5|
|AGE|AGE|11d|
||IP|10.8.0.60|
||NODE|master01|
||NOMINATED NODE|<none>|
||READINESS GATES|<none>|

  

To view all the fields that are associated with a resource, the `describe` subcommand shows a detailed description of the selected resource and related resources. You can select a single object by name, or all objects of that type, or provide a name prefix, or a label selector.

For example, the following command first looks for an exact match on the `TYPE` object and the `NAME-PREFIX` object. If no such resource exists, then the command outputs details for every resource of that type with a name with a `NAME_PREFIX` prefix.

```
[user@host ~]$ **``oc describe _`TYPE`_ _`NAME-PREFIX`_
`````**

The `describe` subcommand provides detailed human-readable output. However, the format of the `describe` output might change between versions, and thus is not recommended for script development. Any scripts that rely on the output of the `describe` subcommand might break after a version update.

Kubernetes provides YAML and JSON-formatted output options that are suitable for parsing or scripting.

#### YAML Output

The `-o yaml` option provides a YAML-formatted output that is parsable and still human-readable.

```
[user@host ~]$ **`oc get pods -o yaml`**
apiVersion: v1
items:
- apiVersion: v1
  kind: Pod
  metadata:
    annotations:
_...object omitted..._
```

**Note**

The reference documentation provides a more detailed introduction to YAML.

You can use any tool that can process YAML documents to filter the YAML output for your chosen field. For example, you can use the `yq` tool at [https://mikefarah.gitbook.io/yq/](https://mikefarah.gitbook.io/yq/) to process YAML and JSON files.

The `yq` processor uses a dot notation to separate field names in a query. The following example pipes the YAML output to the `yq` command to parse the `podIP` field.

```
[user@host ~]$ **`oc get pods -o yaml | yq r - 'items[0].status.podIP'`**
10.8.0.60
```

The `[0]` in the example specifies the first index in the items array.

**Note**

The lab environment includes version 3.3.0 of the `yq` command, which these examples use. Later versions of the `yq` command introduce incompatibilities with earlier versions. The content in this course might not work with other versions.

**Note**

Another tool named `yq` is at [https://kislyuk.github.io/yq/](https://kislyuk.github.io/yq/). The two `yq` tools are not compatible; commands that are designed for one of them do not work with the other.

#### JSON Output

Kubernetes uses the JSON format internally to process resource objects. Use the `-o json` option to view a resource in the JSON format.

```
[user@host ~]$ **`oc get pods -o json`**
{
    "apiVersion": "v1",
    "items": [
        {
            "apiVersion": "v1",
            "kind": "Pod",
            "metadata": {
                "annotations": {
```

You can use other tools to process JSON documents, such as the `jq` tool at [https://jqlang.github.io/jq/](https://jqlang.github.io/jq/). Similar to the `yq` processor, use the `jq` processor and dot notation on the fields to query specific information from the JSON-formatted output.

```
[user@host ~]$ **`oc get pods -o json | jq '.items[0].status.podIP'`**
"10.8.0.60"
```

Alternatively, the example might have used `.items[].status.podIP` for the query string. The empty brackets instruct the `jq` tool to query all items.

#### Custom Output

Kubernetes provides a custom output format that combines the convenience of extracting data via `jq` styled queries with a tabular output format. Use the `-o custom-columns` option with comma-separated <column name> : <jq query string> pairs.

```bash
[user@host ~]$ oc get pods \
-o custom-columns=PodName:".metadata.name",\
ContainerName:"spec.containers[].name",\ 
Phase:"status.phase",\
IP:"status.podIP",\
Ports:"spec.containers[].ports[].containerPort"
PodName                  ContainerName   Phase     IP          Ports
myapp-77fb5cd997-xplhz   myapp           Running   10.8.0.60   <none>
```

Kubernetes also supports the use of JSONPath expressions. JSONPath is a query language for JSON. JSONPath expressions refer to a JSON data structure; they filter and extract formatted fields from JSON objects.

In the following example, the JSONPath expression uses the `range` operator to iterate over the list of pods to extract the name of the pod, its IP address, and the assigned ports.

```bash
[user@host ~]$ oc get pods  \
-o jsonpath='{range .items[]}{"Pod Name: "}{.metadata.name}
{"IP: "}{.status.podIP}
{"Ports: "}{.spec.containers[].ports[].containerPort}{"\n"}{end}'
Pod Name: myapp-77fb5cd997-xplhz
IP: 10.8.0.60
Ports:
```

You can customize the format of the output with Go templates, which the Go programming language uses. Use the `-o go-template` option followed by a Go template, where Go expressions are inside double braces, `{{` `}}`.

```bash
[user@host ~]$ oc get pods \
-o go-template='{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'
myapp-77fb5cd997-xplhz
```

## Assess the Health of an OpenShift Cluster

### Query Operator Conditions

Operators are important components of Red Hat OpenShift Container Platform (RHOCP). 

Operators automate the required tasks to maintain a healthy RHOCP cluster that would otherwise require human intervention. Operators are the preferred method of packaging, deploying, and managing services on the control plane.

Operators integrate with Kubernetes APIs and CLI tools such as `kubectl` and `oc` commands. Operators provide the means of monitoring applications, performing health checks, managing over-the-air (OTA) updates, and ensuring that applications remain in your specified state.

Because CRI-O and the Kubelet run on every node, almost every other cluster function can be managed on the control plane by using Operators. Components that are added to the control plane by using operators include critical networking and credential services.

Operators in RHOCP are managed by two different systems, depending on the purpose of the operator.

**Cluster Version Operator (CVO)***

Cluster operators perform cluster functions. These operators are installed by default, and the CVO manages them.

Cluster operators use a Kubernetes `kind` value of `clusteroperators`, and thus can be queried via `oc` or `kubectl` commands. As a user with the `cluster-admin` role, use the `oc get clusteroperators` command to list all the cluster operators.

```bash
[user@host ~]$ oc get clusteroperators
NAME                        VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE   MESSAGE
authentication              4.14.0    True        False         False      3d1h
baremetal                   4.14.0    True        False         False      38d
cloud-controller-manager    4.14.0    True        False         False      38d
cloud-credential            4.14.0    True        False         False      38d
cluster-autoscaler          4.14.0    True        False         False      38d
config-operator             4.14.0    True        False         False      38d
console                     4.14.0    True        False         False      38d
_...output omitted..._
```

For more details about a cluster operator, use the ``describe clusteroperators _`operator-name`_`` command to view the field values that are associated with the operator, including the current status of the operator. The `describe` command provides a human-readable output format for a resource. As such, the output format might change with an RHOCP version update.

For an output format that is less likely to change with a version update, use one of the `-o` output options of the `get` command. For example, use the following `oc get clusteroperators` command for the YAML-formatted output details for the `dns` operator.

```bash
[user@host ~]$ oc get clusteroperators dns -o yaml
apiVersion: config.openshift.io/v1
kind: ClusterOperator
metadata:
  annotations:
_...output omitted..._
status:
  conditions:
  - lastTransitionTime: "2023-03-20T13:55:21Z"
    message: DNS "default" is available.
    reason: AsExpected
    status: "True"
    type: Available
_...output omitted..._
  relatedObjects:
  - group: ""
    name: openshift-dns-operator
    resource: namespaces
_...output omitted..._
  versions:
  - name: operator
    version: 4.14.0
_...output omitted..._
```

**Operator Lifecycle Manager (OLM) Operators

Optional add-on operators that the OLM manages can be made accessible for users to run in their applications.

As a user with the `cluster-admin` role, use the `get operators` command to list all the add-on operators.

```bash
[user@host~]$ oc get operators
NAME                                 AGE
lvms-operator.openshift-storage      34d
metallb-operator.metallb-system      34d
```

You can likewise use the `describe` and `get` commands to query details about the fields that are associated with the add-on operators.

Operators use one or more pods to provide cluster services. You can find the namespaces for these pods under the `relatedObjects` section of the detailed output for the operator. As a user with a `cluster-admin` role, use the `-n namespace` option on the `get pod` command to view the pods. For example, use the following `get pods` command to retrieve the list of pods in the `openshift-dns-operator` namespace.

```bash
[user@host~]$ oc get pods -n openshift-dns-operator
NAME                            READY   STATUS    RESTARTS   AGE
dns-operator-64688bfdd4-8zklh   2/2     Running   38         38d
```

Use the `-o yaml` or `-o json` output formats to view or analyze more details about the pods. The resource conditions, which are found in the status for the resource, track the current state of the resource object. The following example uses the `jq` processor to extract the `status` values from the JSON output details for the `dns` pod.

```bash
[user@host~]$ oc get pod -n openshift-dns-operator \
dns-operator-64688bfdd4-8zklh -o json | jq .status
{
  "conditions": [
    {
      "lastProbeTime": null,
      "lastTransitionTime": "2023-02-09T21:24:50Z",
      "status": "True",
      "type": "Initialized"
    },
_...output omitted..._
```

In addition to listing the pods of a namespace, you can also use the `--show-labels` option of the `get` command to print the labels used by the pods. The following example retrieves the pods and their labels in the `openshift-etcd` namespace.

```bash
[user@host~]$ oc get pods -n openshift-etcd --show-labels
NAME                   READY   STATUS      RESTARTS   AGE   LABELS
etcd-master01          4/4     Running     68         35d   app=etcd,etcd=true,k8s-app=etcd,revision=3
installer-3-master01   0/1     Completed   0          35d   app=installer
```

### Examining Cluster Metrics

Another way to gauge the health of an RHOCP cluster is to examine the compute resource usage of cluster nodes and pods. The `oc adm top` command provides this information. For example, to list the total memory and CPU usage of all pods in the cluster, you can use the `--sum` option with the command to print the sum of the resource usage.

```bash
[user@host~]$ oc adm top pods -A --sum
NAMESPACE                 NAME                      CPU(cores)   MEMORY(bytes)
metallb-system            controller-...-ddr8v      0m           57Mi
metallb-system            metallb-...-n2zsv         0m           48Mi
_...output omitted..._
openshift-storage         topolvm-node-9spzf        0m           68Mi
openshift-storage         vg-manager-z8g5k          0m           23Mi
                                                   ------       --------
                                                    428m         10933Mi
```

The `-A` option shows pods from all namespaces. Use the `-n namespace` option to filter the results to show the pods in a single namespace. Use the `--containers` option to display the resource usage of containers within a pod. For example, use the following command to list the resource usage of the containers in the `etcd-master01` pod in the `openshift-etcd` namespace.

```bash
[user@host~]$ oc adm top pods etcd-master01 -n openshift-etcd --containers
POD             NAME           CPU(cores)   MEMORY(bytes)
etcd-master01   POD            0m           0Mi
etcd-master01   etcd           71m          933Mi
etcd-master01   etcd-metrics   6m           32Mi
etcd-master01   etcd-readyz    4m           66Mi
etcd-master01   etcdctl        0m           0Mi
```

#### Viewing Cluster Metrics

The OpenShift web console incorporates graphs to visualize cluster and resource analytics. Cluster administrators and users with either the `view` or the `cluster-monitoring-view` cluster role can access the Home → Overview page. The Overview page displays a collection of cluster-wide metrics, and provides a high-level view of the overall health of the cluster.

The Overview page displays the following metrics:

- Current cluster capacity based on CPU, memory, storage, and network usage
- A time-series graph of total CPU, memory, and disk usage
- The ability to display the top consumers of CPU, memory, and storage

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/cli/health/assets/console-metrics-dash-utilization.png)|

For any of the listed resources in the Cluster Utilization section, administrators can click the link for current resource usage. The link displays a window with a breakdown of top consumers for that resource. Top consumers can be sorted by project, by pod, or by node. The list of top consumers can be useful for identifying problematic pods or nodes. For example, a pod with an unexpected memory leak might appear at the top of the list.

#### Viewing Project Metrics

The Project Details page displays metrics that provide an overview of the resources that are used within the scope of a specific project. The Utilization section displays usage information about resources, such as CPU and memory, along with the ability to display the top consumers for each resource.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/cli/health/assets/console-metrics-project-details.png)|

All metrics are pulled from Prometheus. Click any graph to navigate to the Metrics page. View the executed query, and inspect the data further.

If a resource quota is created for the project, then the current project request and limits appear on the Project Details page.

#### Viewing Resource Metrics

When troubleshooting, it is often useful to view metrics at a smaller granularity than for the entire cluster or project. The Pod Details page displays time-series graphs of the CPU, memory, and file system usage for a specific pod. A sudden change in these critical metrics, such as a CPU spike caused by high load, is visible on this page.

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/cli/health/assets/console-metrics-pod-details.png)|

Figure 2.9: Time-series graphs showing various metrics for a pod

#### Performing Prometheus Queries in the Web Console

The Prometheus UI is a feature-rich tool for visualizing metrics and configuring alerts. The OpenShift web console provides an interface for executing Prometheus queries directly from the web console.

To perform a query, navigate to Observe → Metrics, enter a Prometheus Query Language expression in the text field, and click Run Queries. The results of the query are displayed as a time-series graph:

|   |
|---|
|![](https://static.ole.redhat.com/rhls/courses/do180-4.14/images/cli/health/assets/console-metrics-prometheus.png)|

Figure 2.10: Using a Prometheus query to display a time-series graph

***Note

The Prometheus Query Language is not discussed in detail in this course. Refer to the references section for a link to the official documentation.

### Query Cluster Events and Alerts

Some developers consider OpenShift logs to be too low-level, thus making troubleshooting difficult. Fortunately, RHOCP provides a high-level logging and auditing facility called _events_. Kubernetes generates `event` objects in response to state changes in cluster objects, such as nodes, pods, and containers. Events signal significant actions, such as starting a container or destroying a pod.

To read events, use the `get events` command. The command lists the events for the current RHOCP project (namespace). You can display the events for a different project by adding the ``-n _`namespace`_`` option to the command. To list the events for all the projects, use the `-A` (or `--all-namespaces`) option.

***Note

To sort the events by time, add the `--sort-by .metadata.creationTimestamp` option to the `oc get events` command.

The following `get events` command prints events in the `openshift-kube-controller-manager` namespace.

```bash
[user@host~]$ oc get events -n openshift-kube-controller-manager
LAST SEEN  TYPE    REASON                 OBJECT                                MESSAGE
12m        Normal  CreatedSCCRanges       pod/kube-controller-manager-master01  created SCC...
```

You can use the ``describe pod _`pod-name`_`` command to further narrow the results to a single pod. For example, to retrieve only the events that relate to a `mysql` pod, you can refer to the `Events` field from the output of the `oc describe pod mysql` command:

```bash
[user@host~]$ oc describe pod mysql
_...output omitted..._
Events:
  FirstSeen   LastSeen    Count From         Reason          Message
  Wed, 10 ... Wed, 10 ... 1     {scheduler } scheduled       Successfully as...
_...output omitted..._
```

#### Kubernetes Alerts

RHOCP includes a monitoring stack, which is based on the Prometheus open source project. The monitoring stack is configured to monitor the core RHOCP cluster components, by default. You can optionally configure the monitoring stack also to monitor user projects.

The components of the monitoring stack are installed in the `openshift-monitoring` namespace. Use the following `get all` command to display a list of all resources, their status, and their types in the `openshift-monitoring` namespace.

```bash
[user@host~]$ oc get all -n openshift-monitoring --show-kind
NAME                                              READY  STATUS   RESTARTS AGE
pod/`alertmanager-main-0`                           6/6    Running  85       34d
pod/cluster-monitoring-operator-56b769b58f-dtmqj  2/2    Running  34       35d
pod/kube-state-metrics-75455b796c-8q28d           3/3    Running  51       35d
pod/`prometheus-k8s-0`                              6/6    Running  30       35d
_...output omitted..._
```

The Prometheus Operator in the `openshift-monitoring` namespace creates, configures, and manages platform Prometheus and Alertmanager instances. `prometheus-k8s-0` is the Prometheus pod. A cluster administrator can use the following command to get the alerts from the Prometheus API.

```bash
[user@host~]$ oc -n openshift-monitoring exec -c prometheus \ prometheus-k8s-0 -- curl -s   'http://localhost:9090/api/v1/alerts' | jq
_...output omitted..._
```

An Alertmanager pod in the `openshift-monitoring` namespace receives alerts from Prometheus. Alertmanager uses alert receivers to send alerts to external notification systems. The `alertmanager-main-0` pod is the Alertmanager for the cluster. Use the `curl` command to retrieve the fired alerts from the Alertmanager API.

[user@host~]$ **`oc -n openshift-monitoring exec -c alertmanager \ alertmanager-main-0 -- curl -s  'http://localhost:9093/api/v1/alerts' | jq`**
_...output omitted..._

### Check Node Status

RHOCP clusters can have several components, including at least one control plane and at least one compute node. The two components can occupy a single node. The following `oc` command, or the matching `kubectl` command, can display the overall health of all cluster nodes.

```bash
[user@host~]$ oc cluster-info
```

The `oc cluster-info` output is high-level, and can verify that the cluster nodes are running. For a more detailed view into the cluster nodes, use the `get nodes` command.

```bash
[user@host~]$ oc get nodes
NAME       STATUS   ROLES                         AGE   VERSION
master01   Ready    control-plane,master,worker   35d   v1.27.6+f67aeb3
```

The example shows a single `master01` node with multiple roles. The `STATUS` value of `Ready` means that this node is healthy and can accept new pods. A `STATUS` value of `NotReady` means that a condition triggered the `NotReady` status and the node is not accepting new pods.

As with any other RHOCP resource, you can drill down into further details of the node resource with the ``describe node _`node-name`_`` command. For parsable output of the same information, use the `-o json` or the `-o yaml` output options with the ``get node _`node-name`_`` command. For more information about using and parsing these output formats, see [the section called “ Inspect Kubernetes Resources ”](https://rol.redhat.com/rol/app/courses/do180-4.14/pages/ch02s03).

The output of the ``get nodes _`node-name`_`` command with the `-o json` or `-o yaml` option is long. The following examples use the `-jsonpath` option or the `jq` processor to parse the ``get node _`node-name`_`` command output.

```bash
[user@host~]$ oc get node master01 -o jsonpath=\ 
{"Allocatable:\n"}{.status.allocatable}{"\n\n"}
{"Capacity:\n"}{.status.capacity}{"\n"}'
Allocatable:
{"cpu":"7500m","ephemeral-storage":"114396791822","hugepages-1Gi":"0",
"hugepages-2Mi":"0","memory":"19380692Ki","pods":"250"}

Capacity:
{"cpu":"8","ephemeral-storage":"125293548Ki","hugepages-1Gi":"0",
"hugepages-2Mi":"0","memory":"20531668Ki","pods":"250"}
```

The JSONPath expression in the previous command extracts the allocatable and capacity measures for the `master01` node. These measures help to understand the available resources on a node.

View the `status` object of a node to understand the current health of the node.

```bash
[user@host~]$ oc get node master01 -o json | jq '.status.conditions'
[
  {
    "lastHeartbeatTime": "2023-03-22T16:34:57Z",
    "lastTransitionTime": "2023-02-23T20:35:15Z",
    "message": "kubelet has sufficient memory available",
    "reason": "KubeletHasSufficientMemory",
    "status": "False",
    "type": "MemoryPressure"   # ![1]
  },
  {
    "lastHeartbeatTime": "2023-03-22T16:34:57Z",
    "lastTransitionTime": "2023-02-23T20:35:15Z",
    "message": "kubelet has no disk pressure",
    "reason": "KubeletHasNoDiskPressure",
    "status": "False",
    "type": "DiskPressure"   #  ![2]
  },
  {
    "lastHeartbeatTime": "2023-03-22T16:34:57Z",
    "lastTransitionTime": "2023-02-23T20:35:15Z",
    "message": "kubelet has sufficient PID available",
    "reason": "KubeletHasSufficientPID",
    "status": "False",
    "type": "PIDPressure"   #  ![3]
  },
  {
    "lastHeartbeatTime": "2023-03-22T16:34:57Z",
    "lastTransitionTime": "2023-02-23T20:35:15Z",
    "message": "kubelet is posting ready status",
    "reason": "KubeletReady",
    "status": "True",
    "type": "Ready"   #  ![4]
  }
]
```

|     |                                                                                                          |
| --- | -------------------------------------------------------------------------------------------------------- |
| 1   | If the status of the `MemoryPressure` condition is true, then the node is low on memory.                 |
| 2   | If the status of the `DiskPressure` condition is true, then the disk capacity of the node is low.        |
| 3   | If the status of the `PIDPressure` condition is true, then too many processes are running on the node.   |
| 4   | If the status of the `Ready` condition is false, then the node is not healthy and is not accepting pods. |

More conditions indicate other potential problems with a node.

**Table 2.5. Possible Node Conditions**

|Condition|Description|
|:--|:--|
|`OutOfDisk`|If true, then the node has insufficient free space on the node for adding new pods.|
|`NetworkUnavailable`|If true, then the network for the node is not correctly configured.|
|`NotReady`|If true, then one of the underlying components, such as the container runtime or network, is experiencing issues or is not yet configured.|
|`SchedulingDisabled`|Pods cannot be scheduled for placement on the node.|

  

To gain deeper insight into a given node, you can view the logs of processes that run on the node. A cluster administrator can use the `oc adm node-logs` command to view node logs. Node logs might contain sensitive output, and thus are limited to privileged node administrators. Use ``oc adm node-logs _`node-name`_`` to filter the logs to a single node.

The `oc adm node-logs` command has other options to further filter the results.

**Table 2.6. Filters for `oc adm node-logs`**

|Option Example|Description|
|:--|:--|
|`--role master`|Use the `--role` option to filter the output to nodes with a specified role.|
|`-u kubelet`|The `-u` option filters the output to a specified unit.|
|`--path=cron`|The `--path` option filters the output to a specific process under the `/var/logs` directory.|
|`--tail 1`|Use ``--tail _`x`_`` to limit output to the last `x` log entries.|

  

Use `oc adm node-logs --help` for a complete list of command options.

For example, to retrieve the most recent log entry for the `crio` service on the `master01` node, you can use the following command.

```bash
[user@host~]$ oc adm node-logs master01 -u crio --tail 1
-- Logs begin at Thu 2023-02-09 21:19:09 UTC, end at Fri 2023-03-17 15:11:43 UTC. --
Mar 17 06:16:09.519642 master01 crio[2987]: time="2023-03-17 06:16:09.519474755Z" level=info msg="Image status:
&ImageStatusResponse{Image:&Image{Id:6ef8...79ce,RepoTags:[],RepoDigests:
_...output omitted..._
```

When you create a pod with the CLI, the `oc` or `kubectl` command is sent to the `apiserver` service, which then validates the command. The `scheduler` service reads the YAML or JSON pod definition, and then assigns pods to compute nodes. Each compute node runs a `kubelet` service that converts the pod manifest to one or more containers in the CRI-O container runtime.

Each compute node must have an active `kubelet` service and an active `crio` service. To verify the health of these services, first start a debug session on the node by using the `debug` command.

```bash
[user@host~]$ oc debug node/_`node-name`_`
```
Replace the ``_`node-name`_`` value with the name of your node.

***Note

The `debug` command is covered in greater detail in a later section.

Within the debug session, change to the `/host` root directory so that you can run binaries in the host's executable path.

```bash
sh-4.4# chroot /host
```

Then, use the `systemctl is-active` calls to confirm that the services are active.

```bash
sh-4.4# for SERVICES in kubelet crio; do echo ---- $SERVICES ---- ; systemctl is-active $SERVICES ;  echo ""; done
---- kubelet ----
active

---- crio ----
active
```

For more details about the status of a service, use the `systemctl status` command.

```bash
sh-4.4# systemctl status kubelet
● kubelet.service - Kubernetes Kubelet
   Loaded: loaded (/etc/systemd/system/kubelet.service; enabled; vendor preset: disabled)
  Drop-In: /etc/systemd/system/kubelet.service.d
           └─01-kubens.conf, 10-mco-default-madv.conf, 20-logging.conf, 20-nodenet.conf
   Active: active (running) since Thu 2023-03-23 14:39:11 UTC; 1h 26min ago
 Main PID: 3215 (kubelet)
    Tasks: 28 (limit: 127707)
   Memory: 391.7M
      CPU: 14min 34.568s
_...output omitted..._
```

#### Check Pod Status

With RHOCP, you can view logs in running containers and pods to ease troubleshooting. When a container starts, RHOCP redirects the container's standard output and standard error to a disk in the container's ephemeral storage. With this redirect, you can view the container logs by using `logs` commands, even after the container stops. However, the pod hosting the container must still exist.

In RHOCP, the following command returns the output for a container within a pod:

```
[user@host~]$ **``oc logs _`pod-name`_ -c _`container-name`_
```

Replace ``_`pod-name`_`` with the name of the target pod, and replace ``_`container-name`_`` with the name of the target container. The ``-c _`container-name`_`` argument is optional, if the pod has only one container. You must use the ``-c _`container-name`_`` argument to connect to a specific container in a multicontainer pod. Otherwise, the command defaults to the only running container and returns the output.

When debugging images and setup problems, it is useful to get an exact copy of a running pod configuration, and then troubleshoot it with a shell. If a pod is failing or does not include a shell, then the `rsh` and `exec` commands might not work. To resolve this issue, the `debug` command creates a copy of the specified pod and starts a shell in that pod.

By default, the `debug` command starts a shell inside the first container of the referenced pod. The debug pod is a copy of your source pod, with some additional modifications. For example, the pod labels are removed. The executed command is also changed to the '/bin/sh' command for Linux containers, or the 'cmd.exe' executable for Windows containers. Additionally, readiness and liveness probes are disabled.

A common problem for containers in pods is security policies that prohibit a container from running as a root user. You can use the `debug` command to test running a pod as a non-root user by using the `--as-user` option. You can also run a non-root pod as the root user with the `--as-root` option.

With the `debug` command, you can invoke other types of objects besides pods. For example, you can use any controller resource that creates a pod, such as a deployment, a build, or a job. The `debug` command also works with nodes, and with resources that can create pods, such as image stream tags. You can also use the `--image=IMAGE` option of the `debug` command to start a shell session by using a specified image.

If you do not include a resource type and name, then the `debug` command starts a shell session into a pod by using the OpenShift tools image.

[user@host~]$ **`oc debug`**

The next example tests running a job pod as a non-root user.

[user@host~]$ **`oc debug job/test --as-user=1000000`**

The following example creates a debug session for a node.

```bash
[user@host~]$ oc debug node/master01
Starting pod/master01-debug-wtn9r ...
To use host binaries, run `chroot /host`
Pod IP: 192.168.50.10
If you don't see a command prompt, try pressing enter.
sh-4.4# chroot /host
sh-5.1#
```

The debug pod is deleted when the remote command completes, or when the user interrupts the shell.

### Collect Information for Support Requests

When opening a support case, it is helpful to provide debugging information about your cluster to Red Hat Support. It is recommended that you provide the following information:

- Data gathered by using the `oc adm must-gather` command as a cluster administrator
    
- The unique cluster ID
    

The `oc adm must-gather` command collects resource definitions and service logs from your cluster that are most likely needed for debugging issues. This command creates a pod in a temporary namespace on your cluster, and the pod then gathers and downloads debugging information. By default, the `oc adm must-gather` command uses the default plug-in image, and writes into the `./must-gather.local.` directory on your local system. To write to a specific local directory, you can also use the `--dest-dir` option, such as in the following example:

[user@host~]$ **`oc adm must-gather --dest-dir /home/student/must-gather`**

Then, create a compressed archive file from the `must-gather` directory. For example, on a Linux-based system, you can run the following command:

[user@host~]$ **`tar cvaf mustgather.tar must-gather/`**

Replace `must-gather/` with the actual directory path.

Then, attach the compressed archive file to your support case in the Red Hat Customer Portal.

Similar to the `oc adm must-gather` command, the `oc adm inspect` command gathers information on a specified resource. For example, the following command collects debugging data for the `openshift-apiserver` and `kube-apiserver` cluster operators.

[user@host~]$ **`oc adm inspect clusteroperator/openshift-apiserver \ clusteroperator/kube-apiserver`**

The `oc adm inspect` command can also use the `--dest-dir` option to specify a local directory to write the gathered information. The command shows all logs by default. Use the `--since` option to filter the results to logs that are later than a relative duration, such as 5s, 2m, or 3h.

[user@host~]$ **`oc adm inspect clusteroperator/openshift-apiserver --since 10m`**
